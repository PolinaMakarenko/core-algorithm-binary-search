# Упражнения на алгоритмы: Бинарный поиск

## Введение

В предыдущей задаче мы написали алгоритм линейного поиска для того, чтобы осуществить работу поиска, который имитировал поведение метода `.indexOf`. В этой задаче мы будем реализовывать тот же процесс, только используя другой алгоритм: бинарный поиск.

### Линейный поиск

В линейном поиске мы просматривали по одному элементу за раз. Чем больше массив, тем больше сравнений нашей программе нужно было сделать во время поиска необходимого ей объекта. Другими словами, связь между размером массива и количеством операций, которые должна выполнить ваша программа, является линейной, поскольку они увеличиваются на этапе блокировки.

Линейный поиск очень полезен и очень прост, но представьте себе массив с миллионом элементов. В худшем случае вы можете искать элемент в конце этого длинного массива. Линейный поиск должен будет сделать 999,999 проверок, прежде чем он наконец доберется до этого последнего элемента!

Существует ли более эффективный способ?

### Более эффективный поиск

Давайте рассмотрим поиск по большому списку элементов, которые уже отсортированы. Словари - отличный пример сортированного набора данных. Мы имеем тысячи слов в одном словаре, отсортированном по алфавиту. Если бы вам пришлось искать слово в словаре, как бы вы это сделали?

Если бы Вы были линейным поиском, Вы начали бы на странице 1 в «А» и прокладывали себе путь до тех пор, пока не найдете свой результат. На практике, однако, мы этого никогда не делаем.

Более общий подход заключается в том, чтобы перевернуть словарь, открывающийся где-то посередине, и выяснить, нужно ли продолжить поиск влево или вправо. Если мы ищем слово «Золотой», а страница, которую мы открываем, имеет слово «Салат», мы знаем, что нам нужно идти влево, потому что «З» доходит до «С».

Если мы ищем влево, мы будем игнорировать правую половину словаря и разделить левую половину где-то посередине. На этот раз мы можем приземлиться в «Д», что означает, что нам на этот раз нужно искать в правой части. Если мы продолжим это, мы, в конце концов, найдем наше слово или обнаружим, что оно вообще не находится в словаре.

Подумайте, что здесь происходит. Как этот подход выступает против линейного поиска? Что будет быстрее? Если отношение линейного поиска к размеру массива является линейным, то верно ли то же самое и для нашего подхода?




### Бинарный поиск

Стратегия поиска словаря, о которой мы говорим выше, действительно представляет собой бинарный поиск. Он называется «бинарным», потому что каждый раз, когда вы открываете словарь и решаете идти влево или вправо, вы делаете бинарный (двоичный) выбор. Этот двоичный выбор означает, что наше «пространство поиска» уменьшается с каждым шагом на половину. Это резко контрастирует с подходами «один на один», который предлагает нам линейный поиск.

Если описать наш метод бинарного поиска в псевдокоде, это будет выглядеть так:

 1. Выберите точку в середине
 2. Сравните то, что мы находим в середине, с тем, что мы ищем.
 3. Если мы нашли то, что искали, мы закончили!
 4. Если мы не нашли то, что искали, выберите левую или правую половину, чтобы продолжить поиск
 5. Примените тот же процесс к нашей новой половине

Вот анимация, которая делает это в списке отсортированных номеров:

![анимация бинарного поиска](readme-assets/binary-search.gif)

*Рисунок 1*. Поиск в упорядоченном наборе данных с использованием алгоритма бинарного поиска.


### Скрытая сложность

На первый взгляд, написание алгоритма бинарного поиска может показаться простым заданием, но очень часто в его алгоритме можно найти ошибки. В книге *Programming Pearls* Джон Бентли писал, что за два часа,90% профессиональных программистов не смогли написать правильную реализацию бинарного поиска. Дональд Кнут в книге *Искусство программирования* писал, что хотя первый бинарный поиск был опубликован в 1946 году, первый поиск без ошибок не был опубликован до 1962 года. Принятие основанного на тестах подхода к разработке может помочь нам избегать ошибок в нашем алгоритме.

Идите медленно и не бойтесь «ставить» все! Когда Вы выполняете детально-ориентированную работу, крайне важно быть методичным и последовательным в Вашем подходе.

### Ограничения

Наше решение должно быть рекурсивным. Двоичный поиск является классическим рекурсивным алгоритмом и предлагает хорошую практику.

Нам также необходимо выполнить эту задачу, не полагаясь на встроенные в JS методы  `map/reduce/flter`. Единственными методами, которые мы можем обращаться к массиву, являются `array[]` и `array.length`.

## Релизы
### Релиз 0: реализация двоичного поиска

Теперь давайте реализуем наш метод бинарного поиска `binarySearch`. Этот метод должен искать элемент в массиве и возвращать его индекс или `-1`, если элемент не находится в массиве.

Например, если мы ищем `G` в массиве `[A, B, C, D, E, F, G, H]`, наш метод должен возвращать 6. Если мы ищем `X`, он должен возвращать `-1`. Ваш метод может подразумевать, что любой полученный массив уже отсортирован.

Однако не погружайтесь сразу, делайте предварительное планирование и псевдокодирование. Помните наш первоначальный план:

 1. Выберите точку в середине
 2. Сравните то, что мы находим в середине, с тем, что мы ищем.
 3. Если мы нашли то, что искали, мы закончили!
 4. Если мы не нашли то, что искали, выберите левую или правую половину, чтобы продолжить поиск
 5. Примените тот же процесс к нашей новой половине

Конечно, этого недостаточно, чтобы найти элемент, поскольку вам нужно выяснить, как вернуть индекс этого элемента. Сделайте это шаг за шагом.

#### Важное значение имеет тестирование

Для этой задачи не было написано никаких тестов. Нам нужно будет написать их самостоятельно для того, чтобы определить, работает ли наш метод должным образом. Мы можем попытаться свести к минимуму вероятность введения ошибок в наш алгоритм бинарного поиска, используя подход, основанный на тестах. Мы можем начать с простого и постепенно усложнять. Работает ли наш метод, когда массив, который мы ищем, пуст? Что делать, если в массиве один элемент, два элемента и т. д.? Существуют ли другие крайние случаи, которые мы должны проверить?

### Релиз 1: Рефакторинг

Прежде чем завершить эту задачу, давайте прочитаем наш код, чтобы узнать, можем ли мы его как - нибудь улучшить. Следуем ли мы Руководству по стилю JavaScript (например, интервалы и отступы)? Могут ли наши имена переменных быть более смысловыми? Есть ли проблемы в коде, которые мы можем устранить? Например, есть ли какие-либо иные функции, которые мы могли бы вынести из нашего метода `binarySearch`?

Наличие прочного набора тестов очень сильно поможет нам в рефакторинге. Мы должны проводить рефакторинг только тогда, когда наши тесты работают должным образом. Поскольку мы осуществляем рефакторинг, то с тестами все должно быть в порядке. Также, благодаря тестам, мы сможем узнать о том, когда наш рефакторинг нарушит действующий код.


## Выводы

Подобно линейному поиску, двоичный поиск - это еще один общий алгоритм поиска и тот, с которым мы должны быть знакомы. Предполагая, что мы ищем упорядоченный набор данных, бинарный поиск будет более эффективным, чем метод линейного поиска, особенно по мере увеличения размера набора данных.
